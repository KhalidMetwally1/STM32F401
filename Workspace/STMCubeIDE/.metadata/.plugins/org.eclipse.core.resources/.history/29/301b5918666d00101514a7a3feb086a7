/*
 * SYSTICK_program.c
 *
 *  Author: Khalid Metwally
 *   Layer: Core Peripheral
 *	   SWC: SYSTICK
 */
#include "STD_TYPES.h"
#include "BIT_MATH.h"

#include "SYSTICK_interface.h"
#include "SYSTICK_config.h"
#include "SYSTICK_private.h"
/*==============================================================================================================*/
/*
 * Brief    : Initializes the SysTick timer with default settings (processor clock, no interrupt).
 * Parameters: void
 * Return   : void
 */
void SYSTICK_voidInit(void)
{
	#if SYSTICK_CLOCK_SOURCE == AHB_CLOCK_SOURCE
	{
		SET_BIT(SYSTICK->CTRL , 2);
	}
	#elif SYSTICK_CLOCK_SOURCE == AHB_Diveded_By_8
	{
		CLR_BIT(SYSTICK->CTRL , 2);
	}
	#endif
}
/*==============================================================================================================*/
/*
 * Brief    : Configures whether the SysTick timer will generate an interrupt on countdown completion.
 * Parameters:
 *      => Copy_uddtState --> Interrupt State [ INT_ENABLE, INT_DISABLE ]
 * Return   : void
 */
void SYSTICK_voidConfigureInterruptState(u8 Copy_u8State)
{
	if (Copy_u8State == INT_DISABLE)
	{
		CLR_BIT(SYSTICK->CTRL , 1);
	}
	else if (Copy_u8State == INT_ENABLE)
	{
		SET_BIT(SYSTICK->CTRL , 1);
	}
}
/*==============================================================================================================*/
/*
 * Brief    : Starts the SysTick timer with a specified number of ticks.
 * Parameters:
 *      => Copy_u32TicksValue --> Number of ticks before the timer expires (max 24-bit value).
 * Return   : void
 */
void SYSTICK_voidStart(u32 Copy_u32TicksValue)
{
	SYSTICK->LOAD = Copy_u32TicksValue;
	SYSTICK->VAL  = 0;
	SET_BIT(SYSTICK ->CTRL , 0);
}
/*==============================================================================================================*/
/*
 * Brief    : Creates a blocking delay in milliseconds using the SysTick timer.
 * Parameters:
 *      => Copy_u32DelayTime --> Delay time in milliseconds
 * Return   : void
 */
void SYSTICK_voidDelay_ms(u32 Copy_u32DelayTime)
{
	SYSTICK_voidStart(Copy_u32DelayTime*2000);
	while(!(GET_BIT(SYSTICK->CTRL , 16) ) )
	{
		/* nothing */
	}
	CLR_BIT(SYSTICK->CTRL, 0);
}
/*==============================================================================================================*/
/*
 * Brief    : Creates a blocking delay in microseconds using the SysTick timer.
 * Parameters:
 *      => Copy_u32DelayTime --> Delay time in microseconds
 * Return   : void
 */
void SYSTICK_voidDelay_us(u32 Copy_u32DelayTime)
{
	SYSTICK_voidStart(Copy_u32DelayTime*2);
	while(!(GET_BIT(SYSTICK->CTRL , 16) ) )
	{
		/* nothing */
	}
	CLR_BIT(SYSTICK->CTRL, 0);
}
/*==============================================================================================================*/
/*
 * Brief    : Returns the number of ticks that have elapsed since the timer started.
 * Parameters: void
 * Return   : u32 --> Elapsed tick count " LOAD Register Minus VAL Register "
 */
u32	 SYSTICK_u32GetElapsedTime(void)
{
	return (SYSTICK->LOAD) - (SYSTICK->VAL);
}
/*==============================================================================================================*/
/*
 * Brief    : Returns the number of ticks remaining before the timer expires.
 * Parameters: void
 * Return   : u32 --> Remaining tick count " VAL Register "
 */
u32	 SYSTICK_u32GetRemainingTime(void)
{
	return (SYSTICK->VAL);
}
/*==============================================================================================================*/

